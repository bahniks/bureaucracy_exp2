<!DOCTYPE HTML>
<html>
  <head>
    <style>
      body {
        margin: 0px;
        padding: 0px;
        overflow: hidden;
      }

      script {
        display: none;
      }
    </style>
  </head>
  <body>
    <canvas id="myCanvas"></canvas>
    {% csrf_token %}
    <script>
      (function main() {
        const csrftoken = document.querySelector('[name=csrfmiddlewaretoken]').value;


        window.requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame
        window.cancelAnimFrame = window.cancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.webkitCancelAnimationFrame ||window.mozCancelRequestAnimationFrame || 
                                 window.mozCancelAnimationFrame || window.oCancelRequestAnimationFrame || window.oCancelAnimationFrame || window.msCancelRequestAnimationFrame || window.msCancelAnimationFrame;

        function init() {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
          hSize = window.innerWidth / 9;
          vSize = window.innerHeight / 5;
          font = Math.round(hSize/5).toString() + "px Helvetica";
        }

        function drawSquare(square, context) {
          context.beginPath();
          context.rect(square.x, square.y - square.size, square.size, square.size);
          context.fillStyle = square.color;
          context.fill();
        }

        function drawTriangle(triangle, context) {
          context.beginPath();
          context.moveTo(triangle.x, triangle.y);
          context.lineTo(triangle.x + triangle.size, triangle.y);
          context.lineTo(triangle.x + triangle.size/2, triangle.y - triangle.size);
          context.closePath();
          context.fillStyle = triangle.color;
          context.fill();
        }

        function drawCircle(circle, context) {
          context.beginPath();
          context.arc(circle.x+circle.size/2, circle.y-circle.size/2, circle.size/2, 0, 2 * Math.PI);
          context.closePath();
          context.fillStyle = circle.color;
          context.fill();
        }

        let animationRequest;
        let lastTime;
        var cumTime = 0;
        function animate(time) {
          if (lastTime === undefined) {
            lastTime = time;
          }
          const timeDiff = time - lastTime;
          lastTime = time;
          cumTime += timeDiff;

          // pixels / second
          var linearDistEachFrame = speed * hSize * timeDiff / 1000;
          var newX = currentObject.x + linearDistEachFrame;
          currentObject.x = newX;
          
          if(newX > canvas.width + hSize / 2) {
            date = new Date();
            saveData({
              "order": trial,  
              "time_screen": cumTime, //date.getTime() - currentObject.time,
              "shape": currentObject.shape,
              "color": currentObject.color,  
              "bribe": currentObject.bribe,
              "response_shape": "NA",
              "response_color": "NA",
              "correct_shape": false,
              "correct_color": false,
              "charity_total": charity,
              "reward_total": reward,
              "response_number": "NA",
              "color1": potColors[0],
              "color2": potColors[1],
              "color3": potColors[2],
              "shape1": potShapes[0],
              "shape2": potShapes[1],
              "shape3": potShapes[2],    
              "condition": condition,
              "lastTrial": trial == totalTrials,
            });
            if(trial <= totalTrials) {
              newTrial();
            } else {
              return;
            }
          }

          // clear
          context.clearRect(0, 0, canvas.width, canvas.height);

          // draw
          currentObject.fun(currentObject, context);
          if(currentObject.bribe != 0) {
            createBribe(currentObject.bribe, newX, currentObject.y);
          }
          createPots();
          createInfo();

          if(!paused && trial <= totalTrials) {
            // request new frame
            animationRequest = window.requestAnimFrame(animate);
          }
        }

        function shuffle(a) {
          var j, x, i;
          for (i = a.length - 1; i > 0; i--) {
              j = Math.floor(Math.random() * (i + 1));
              x = a[i];
              a[i] = a[j];
              a[j] = x;
          }
          return a;
        }

        function sample(a) {
          return a[Math.floor(Math.random() * a.length)];
        }

        const shapes = ["triangle", "circle", "square"];
        const colors = ["yellow", "orange", "skyblue"];
        const shapeFunctions = {
          triangle: drawTriangle,
          circle: drawCircle,
          square: drawSquare,
        };

        var potShapes = shuffle(shapes);
        var potColors = shuffle(colors);

        function createPots() {
          for (i = 0; i < 3; i++) {
            fun = shapeFunctions[potShapes[i]];
            var x = (i+1)*window.innerWidth/4 - hSize/2;
            fun({
              x: x,
              y: window.innerHeight - 100,
              size: hSize,
              color: potColors[i],
            }, context);
            context.font = font;
            context.fillStyle = "black";
            context.textAlign = "center";
            context.fillText(i + 1, x + hSize/2, window.innerHeight - 50);
          }
        }

        function changePotsColors() {
          potColors = shuffle(colors);
          createPots();
        }

        function createObject() {
          var shape = sample(shapes);
          var color = sample(colors);
          var congruent = potShapes[potColors.indexOf(color)] == shape;
          if(Math.random() < bribeProbability && !congruent) {
            var bribe = sample(bribeSizes);
          } else {
            var bribe = 0;
          }
          var date = new Date();
          var object = {
              x: -2*hSize,
              y: window.innerHeight/2,
              color: color,
              shape: shape,
              size: hSize,
              fun: shapeFunctions[shape],
              bribe: bribe,
              time: date.getTime(),
          };
          return object;
        }

        function createBribe(bribe, x, y) {
          if(isPractice) {
            return;
          }
          context.font = font;
          context.fillStyle = "black";
          context.textAlign = "center";
          context.textBaseline = "middle";
          context.fillText(bribe, x + hSize/2, y - hSize/2);
        }

        function createInfo() {
          context.font = font;
          context.fillStyle = "black";
          context.textAlign = "center";
          context.textBaseline = "middle";
          context.fillText(trial.toString() + "/" + totalTrials.toString(), window.innerWidth/2, vSize/5);
          if(isPractice) {
            if(previousCorrect != null) {
              if(previousCorrect) {
                context.fillText("Předchozí objekt byl zařazen SPRÁVNĚ.", window.innerWidth/2, window.innerHeight/2 + vSize/2);
              } else {
                context.fillText("Předchozí objekt byl zařazen CHYBNĚ.", window.innerWidth/2, window.innerHeight/2 + vSize/2);
              }
            }
            return;
          }
          context.textAlign = "right";
          context.fillText("Charitě: " + charity.toString(), window.innerWidth - hSize/10, vSize/5);
          context.fillText("Odměna: " + reward.toString(), window.innerWidth - hSize/10, window.innerHeight/2 + vSize/2);
        }

        document.addEventListener('keydown', function(event) {
          if(["1", "2", "3"].includes(event.key)) {
            // if shape is correct
            if(currentObject.shape == potShapes[parseInt(event.key)-1]) {
              reward += currentObject.bribe;
              if(isPractice) {
                previousCorrect = true;
              }
            }          
            // if color is NOT correct
            if(currentObject.color != potColors[parseInt(event.key)-1]) {
              charity -= charityLoss;
              if(isPractice) {
                previousCorrect = false;
              }
            }      
            reward += sortReward;
            date = new Date();
            saveData({
              "order": trial,  
              "time_screen": cumTime, // date.getTime() - currentObject.time,
              "shape": currentObject.shape,
              "color": currentObject.color,  
              "bribe": currentObject.bribe,
              "response_shape": potShapes[parseInt(event.key)-1],
              "response_color": potColors[parseInt(event.key)-1],
              "correct_shape": potShapes[parseInt(event.key)-1] == currentObject.shape,
              "correct_color": potColors[parseInt(event.key)-1] == currentObject.color,
              "charity_total": charity,
              "reward_total": reward,
              "response_number": event.key,
              "color1": potColors[0],
              "color2": potColors[1],
              "color3": potColors[2],
              "shape1": potShapes[0],
              "shape2": potShapes[1],
              "shape3": potShapes[2],    
              "condition": condition,
              "lastTrial": trial == totalTrials,
            });
            if(trial <= totalTrials) {
              newTrial();
            }
          } else if(event.keyCode == 32) {
            if(paused) {
              unpauseTask();
            } else {
              pauseTask();
            }
          }
        });

        function newTrial() {
          if(trial == totalTrials) {
            window.location.href = window.location.href;
            return;
          }
          trial++;
          if(trial > halfTrials) {
            if(condition == "small_first") {
              bribeSizes = bribeSizesAll.slice(3, 6);
            } else if(condition == "bigfirst") {
              bribeSizes = bribeSizesAll.slice(0, 3);
            }
          }
          changePotsColors();
          currentObject = createObject(); 
          cumTime = 0;
        }

        function saveData(data) {
          if(isPractice) {
            return;
          }
          fetch(window.location.href, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-CSRFToken': csrftoken,
            },
            body: JSON.stringify(data),
          })
        };

        function pauseTask() {
          if(pauseNumber == totalPauses) {
            return;
          }
          pauseNumber += 1;
          paused = true;
          window.cancelAnimFrame(animationRequest);
          context.clearRect(0, 0, canvas.width, canvas.height);
          context.font = font;
          context.fillStyle = "black";
          context.textAlign = "center";
          context.textBaseline = "middle";
          context.fillText("Experiment znovu spustíte zmáčknutím tlačítka MEZERNÍK.", window.innerWidth/2, window.innerHeight/2 - 60);
          context.fillText("Toto byla vaše " + pauseNumber.toString() + ". pauza z celkových " + totalPauses.toString() + ".", window.innerWidth/2, window.innerHeight/2 - 20);
          if(pauseNumber == totalPauses) {
            context.fillText("Experiment nemůže být již pauzován.", window.innerWidth/2, window.innerHeight/2 + 20);
          }
          if(window.innerWidth < minimumWidth || window.innerHeight < minimumHeight) {
            context.fillText(`Okno experimentu musí mít velikost alespoň ${minimumWidth}x${minimumHeight} pixelů!`, window.innerWidth/2, window.innerHeight/2 + 60);
            context.fillText("Zvětšete okno a klikněte na tlačítko OK.", window.innerWidth/2, window.innerHeight/2 + 100);
          }
        }

        function unpauseTask() {
          if(window.innerWidth < minimumWidth || window.innerHeight < minimumHeight) {
            return;
          }
          lastTime = undefined;
          paused = false;
          currentObject.y = window.innerHeight/2;
          currentObject.size = hSize;
          window.requestAnimFrame(animate);
        }

        function tooManyBreaks() {
          window.cancelAnimFrame(animationRequest);
          context.clearRect(0, 0, canvas.width, canvas.height);
          alert("Překročili jste maximální množství pauz. Experiment je ukončen. Můžete zavřít okno experimentu.");         
        }

        // settings
        const initialCharity = 2000;
        const bribeProbability = 0.225;
        const bribeSizesAll = [20, 50, 80, 110, 140, 170];
        const charityLoss = 200;
        const speed = 3;
        const sortReward = 3;
        const isPractice = parseInt("{{practice}}");
        const maxPauseLength = 2;
        const totalPauses = 3;
        const minimumHeight = 700;
        const minimumWidth = 1000;
        if(isPractice) {
          var totalTrials = 6;
        } else {
          var totalTrials = 20;
        }
        const halfTrials = totalTrials / 2;

        // condition
        const condition = sample(["small_first", "control", "big_first"]);
        if(condition == "small_first") {
          var bribeSizes = bribeSizesAll.slice(0, 3);
        } else if(condition == "bigfirst") {
          var bribeSizes = bribeSizesAll.slice(3, 6);
        } else {
          var bribeSizes = bribeSizesAll;
        }

        // current state
        var reward = 0;
        var trial = 1;
        var charity = initialCharity;
        var previousCorrect = null;
        var paused = false;
        var pauseNumber = 0;

        // initialization
        var canvas = document.getElementById('myCanvas');
        var context = canvas.getContext('2d');      
        init();
        createPots();
        var currentObject = createObject();                 
     
        // disable right click
        canvas.addEventListener('contextmenu', event => event.preventDefault());

        // handling resizing
        window.addEventListener("resize", resized);
        function resized() {
          if(!paused) {
            if(window.innerWidth < minimumWidth || window.innerHeight < minimumHeight) {
              if(pauseNumber == totalPauses) {
                tooManyBreaks();
              } else {
                init();
                pauseTask();          
              }
            } else {
              init();
              currentObject.y = window.innerHeight/2;
              currentObject.size = hSize;
            }            
          } else {
            init();
            pauseNumber -= 1;
            pauseTask();
          }
        }

        // visibility
        document.addEventListener("visibilitychange", onChange);
        function onChange() {
          if(document.visibilityState == "hidden" && !paused) {
            if(pauseNumber == totalPauses) {
              tooManyBreaks();
            }
            pauseTask();
          } else if (document.visibilityState == "visible" && !paused && pauseNumber != totalPauses) {
            unpauseTask();
          }
        }

        // starting the animation
        if(window.innerWidth < minimumWidth || window.innerHeight < minimumHeight) {
          pauseNumber -= 1;
          pauseTask();
        } else {
          if (document.visibilityState == "visible") {
            window.requestAnimFrame(animate);
          }
        }

      })();
    </script>
  </body>
</html>      